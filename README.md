# Начало работы

1. Копируем репозиторий и переходим в него:
```sh
git clone https://github.com/Egor213/PullReqService.git
```
```sh
cd PullReqService
```

2. Создаем в нем файл `.env` и копируем содержимое файла `.env.example`. Затем выставляем необходимые на ваш вкус настройки.
(Поскольку по условию задания проект должен запускаться командой docker-compose up сразу после клонирования, без дополнительных действий, этот шаг можно пропустить — файл .env уже включён в репозиторий.)

3. Для запуска проекта можно воспользовать коммандой:  
+ C логами:
```sh
docker-compose up --build -d && docker-compose logs -f  
```
+ Без логов:
```sh
docker-compose up --build -d  
```

После этого сервис будет доступен на `http://localhost:8080`
> При этом `api` находится по адресу: `http://localhost:8080/api/v1`

4. Для завершения работы программы можно использовать команды:
+ Для удаления данных бд:
```sh
docker compose down -v
```
+ Без удаления данных бд:
```sh
docker compose down
```

5. Для запуска тестов можно воспользоваться командой:  
```go
go test -v ./internal/service/...
```

6. Для запуска линтера можно воспользоваться командой:  
```go
golangci-lint run
```

7. Для запуска интеграционных тестов воспользуйтесь коммандой:
```sh
docker compose -f docker-compose.integration-tests.yaml up --build
```
Или
```sh
docker compose -f docker-compose.integration-tests.yaml up --build --abort-on-container-exit --exit-code-from app_test
```


# Стек

- Golang
- Echo (веб фреймворк)
- PostgreSQL (в качестве хранилища данных)
- golang-migrate/migrate (для миграций БД)
- pgx (драйвер для работы с PostgreSQL)
- go-transaction-manager (для работы с транзакциями)
- golang/mock, testify, go-hit (для тестирования)


# Нагрузочное тестирование
Было проведено небольшое нагрузочное тестирование с помощью инструментов `k6`

Проверка ручки `http://localhost:8080/health`  

![](images/health_check.jpg)


Проверка ручки `http://localhost:8080/team/get`

![](images/get_random_team_check.jpg)


Проверка ручки `http://localhost:8080/team/add`

![](images/insert_random_team.jpg)


# Вопросы и размышления

В ходе выполнения работы возникло много вопрос из-за неточности формулировок и описанной схемы API.

1. Так, например, в одном из путей был указан статус код 401, но при этом нигде не указана была информация об авторизации.
> Поэтому я решил добавить простую авторизацию на основе JWT. В ней не используются пароль и фиксированная роль пользователя, так как в таком случае правильнее было бы реализовать полноценный CRUD для управления пользователями, а не городить временные решения. Для получения токена необходимо указать идентификатор существующего пользователя и желаемую роль.

2. В первой ручке в комментариях указано "(создаёт/обновляет пользователей)". То есть, помимо создания, она может редактировать уже существующие команды? Тогда почему присутствует статус код 400 с сообщением "team_name already exists"?
> Я решил позволить обновлять уже существующую команду. При этом пользователи либо создаются как новые, либо перезаписываются. Каждый пользователь может принадлежать только одной команде, поэтому при обновлении команды возможны ситуации, когда команда остаётся без пользователей или пользователь — без команды.   
Также вместо ошибки "team_name already exists" теперь используется сообщение "team with such users already exists". Оно возникает, если при создании или обновлении команды передан набор пользователей, идентификаторы которых совпадают с теми, что уже существуют в другой команде. То есть может прийти пользователь с другим username, но операция завершится ошибкой, если его идентификатор уже закреплён за другой командой.

3. Каждый пользовать может находится в одной команде.
> Я реализовал это именно так, потому что в задании не было упоминаний о другой логике. В противном случае было бы непонятно, из какой команды назначать ревьюера.

4. Может ли неактивный пользователь создавать пулл реквесты?
> Нет.

5. Задумка с mergePR.
> В mergePR может возникнуть следующая ситуация: мы получаем PR → проверяем его статус → выполняем merge. Однако параллельная операция может успеть замержить этот же PR. В результате наша проверка покажет, что PR всё ещё открыт, мы попытаемся выполнить merge и получим ошибку — PR с открытым статусом в базе уже не существует.   
Это  аномалия неповторяющегося чтения. Для решения можно использовать транзакцию с уровнем изоляции REPEATABLE READ.   
Либо можно реализовать другой подход: если при попытке merge возникает ошибка, значит PR либо был удалён, либо уже замержен другой операцией. В таком случае мы повторно запрашиваем PR:   
– если он существует, мы увидим дату merge и поймём, что он уже был закрыт;   
– если PR не удаётся получить повторно, значит он был удалён.      
Этот механизм почти не замедляет выполнение, так как на каждый PR выполняется только один дополнительный запрос и то лишь в крайне редких случаях гонки.

6. В проекте присутствуют тестовые данные (`fixtures`). Консистентность этих данных не гарантированна, но стремится к ней.
Их можно загрузить в бд с помощью комманды (при этом надо не забыть про поднятую базу данных и применненые к ней миграции):
```go
go run cmd/loadfixtures/main.go
```

# P. S.
+ Время для выполнения тестового выпало не самое удачное, поэтому сделал всё, что смог.

+ Хотелось бы написать больше тестов — удалось более-менее покрыть только сервисный слой.

+ Интеграционных тестов тоже получилось мало. Планировал пройтись по каждой ручке, но упёрся во временные ограничения.

+ В целом задание оказалось очень интересным и довольно объёмным для столь малого времени. Некоторые моменты хотелось бы увидеть в более подробном описании, поэтому в некоторых случаях пришлось додумывать детали самостоятельно.

# Примеры работы

![](images/add_ok.jpg)


![](images/create_pr_ok.jpg)


![](images/get_team.jpg)


![](images/login.jpg)


![](images/not_found.jpg)


![](images/set_is_active.jpg)


![](images/unauthorized.jpg)


![](images/reassign.jpg)
